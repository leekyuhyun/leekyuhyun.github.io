---
title: "[week2] 백엔드 기초 : Node.js + Express 기본 (2)"
date: "2026-01-16"
description: "1월 16일 TIL"
thumbnail: "/images/useBlog/TIL.png"
tags: ["프로그래머스 데브코스", "TIL"]
---

### Node.js

- 특징
  - **싱글 스레드**
    - 한 번에 한 가지 일만 처리하는 일꾼이 한 명뿐이지만, 일을 매우 빠르게 번갈아 처리하여 효율적으로 작동
  - **이벤트 기반**
    - 어떤 일(클릭, 요청 등)이 발생했을 때만 미리 정해진 동작을 수행하므로, 자원을 불필요하게 낭비하지 않음
  - **논블로킹 I/O**
    - 시간이 오래 걸리는 작업(파일 읽기, DB 조회 등)을 시켜놓고 결과가 나올 때까지 기다리지 않고, 즉시 다음 업무를 처리

#### 논블로킹 실습

```javascript
//non-blocking-demo.js
function first() {
  console.log("first");
}
function second() {
  console.log("second");
}
function third() {
  console.log("third");
}

first();
setTimeout(second, 2000);
third();

//결과 (콘솔창)
first
third
(약 2초 뒤)
second
```

#### Node.js 동작 원리

1. **first() 실행**
   - **콜 스택(Call Stack)**에 쌓이고 즉시 "first"가 출력된 후 스택에서 제거

2. **setTimeout(second, 2000) 호출 (비동기 작업)**
   - Node.js는 이 작업을 **백그라운드(타이머 부서)**로 넘김
   - 이때 메인 일꾼(싱글 스레드)은 2초를 기다리지 않고 바로 다음 코드로 넘어가는 **논블로킹(Non-blocking)** 특징을 보여줌

3. **third() 실행**
   - 타이머가 돌아가는 동안 기다리지 않고 즉시 실행되어 "third"를 출력

4. **2초 후 second 함수의 이동**
   - 타이머가 완료되면 `second` 함수는 바로 실행되는 것이 아니라, **콜백 큐(Callback Queue)**라는 대기실로 이동하여 자기 차례를 기다림

5. **이벤트 루프(Event Loop)의 작동**
   - **이벤트 루프**가 "콜 스택이 비어있는지" 끊임없이 확인
   - 스택이 완전히 비어있음을 확인하면, 대기실(큐)에 있던 `second`를 스택으로 끌고 올라가 실행시킴

**✅ 최종 출력 결과**
first -> third -> (2초 뒤) -> second

### 모듈

- **전체 프로그렘의 기능을 조각조각 나눠놓은 부품**
  - 내장 모듈
    - Node.js 설치 시 기본으로 제공되는 도구 (예: `http`, `fs`, `os`)
  - 외장 모듈
    - 남들이 만들어서 배포한 도구 (`npm`을 통해 설치, 예: `express`, `mysql`)
  - 사용자 정의 모듈
    - 지금 직접 만들고 있는 `.js 파일들` (예: `non-blocking-demo.js`)

### npm (Node Packgage Manager)

- **Node.js의 패키지(모듈) 관리 도구**
- npm 설치 시 자동 생성되는 파일
  - **package.json**
    - 프로젝트의 **명세서**이자 메뉴판
    - 어떤 모듈(부품)이 필요한지 이름과 버전이 적혀 있어, 프로젝트의 전체 구성을 한눈에 보여줌
  - **package-lock.json**
    - 설치된 모듈들의 **상세 설계도**
    - 모든 팀원이 정확히 똑같은 버전의 코드를 사용할 수 있게 주소와 버전을 꽁꽁 묶어(lock) 관리
  - **node_modules**
    - 실제 모듈 파일들이 담긴 **창고**
    - 용량이 매우 큰 '코드 덩어리'들이라 보통 이 폴더는 공유하지 않고, 명세서(package.json)만 공유해서 각자 새로 내려받아 사용

- **npm 기본 명령어**

```
npm -v               # npm 버전 확인
npm install <모듈>    # 모듈 설치
npm uninstall <모듈>  # 모듈 삭제
```

### 라이브러리 vs 프레임워크 한 눈에 보기

가장 큰 차이는 **"누가 주도권을 가지고 있느냐"**에 있음

**1. 라이브러리 (Library)**

- **정의**
  - 본인이 필요할 때마다 꺼내 쓰는 **'도구 모음'**
- **특징**
  - 전체적인 흐름은 내가 결정하고, 특정 기능(예: 날짜 계산, 그림 그리기)이 필요할 때만 본인이 라이브러리를 호출해서 사용
- **비유**
  - 요리할 때 본인이 필요해서 꺼내 쓰는 **'가위나 칼 같은 도구'** 혹은 **'양념'**과 같음

**2. 프레임워크 (Framework)**

- **정의**
  - 프로그램이 돌아가는 **'기본 틀(뼈대)'**
- **특징**
  - 본인이 프레임워크를 사용하는 게 아니라, 내가 짠 코드를 프레임워크가 가져다가 실행
  - 본인은 프레임워크가 정해둔 규칙(틀)에 맞춰서 코드를 끼워 넣어야 함
- **비유**
  - 이미 모든 재료와 레시피가 정해져 있는 **'밀키트'**나 **'밀가루 틀'**과 같음
  - 본인은 그 안의 내용물만 채우면 됨

#### 오늘 배운 점

- **효율적인 일 처리**
  - Node.js는 한 명의 일꾼(싱글 스레드)이 시간이 걸리는 일을 기다리지 않고 다음 일을 처리하는(논블로킹) 매우 똑똑한 방식으로 움직인다는 것을 배움.
- **부품화의 원리**
  - 프로그램 전체를 하나로 만들지 않고, 모듈이라는 부품으로 쪼개서 관리하고 조립하는 개발의 기본 구조를 이해함.

- **관리 시스템**
  - npm을 통해 남이 만든 부품을 가져오고, `package.json` 같은 명세서를 통해 내 프로젝트를 체계적으로 관리하는 협업의 기초를 익힘.
- **프레임워크 vs 라이브러리**
  - 내가 주도권을 갖고 필요할 때 꺼내 쓰는 도구는 **라이브러리**, 정해진 틀에 맞춰 내 코드를 끼워 넣어야 하는 뼈대는 **프레임워크**라는 차이를 명확히 파악함.
